<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <title>Büyük Silindir ve Cubuk Oyunu</title>
    <style>
        body { margin: 0; overflow: hidden; background: #2c3e50; font-family: sans-serif; }
        canvas { display: block; background: #87CEEB; }
        #ui { position: absolute; top: 15px; width: 100%; text-align: center; pointer-events: none; color: white; }
        h1 { font-size: 36px; margin: 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }
        p { font-size: 20px; font-weight: bold; }
    </style>
</head>
<body>

<div id="ui">
    <h1 id="lvl">Seviye: 1</h1>
    <p id="msg">Sadece birine bas! Doğru sırayı bul.</p>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const imgSilindir = new Image();
const imgCubuk = new Image();
imgSilindir.src = 'Silindir.png';
imgCubuk.src = 'Cubuk.png';

let level = 1;
let cylinders = [];
let correctSeq = [];
let playerIdx = 0;
let isLocked = false;

// BÜYÜTÜLMÜŞ VE AYARLANMIŞ BOYUTLAR
const cylW = 160;   
const cylH = 120;   
const poleW = 70;   

function init() {
    cylinders = [];
    playerIdx = 0;
    isLocked = false;
    const adet = level + 2;
    
    correctSeq = Array.from({length: adet}, (_, i) => i);
    correctSeq.sort(() => Math.random() - 0.5);

    // Silindirler arası boşluğu genişletmek için hesaplama
    const totalWidth = canvas.width;
    const spacing = totalWidth / (adet + 1);

    for (let i = 0; i < adet; i++) {
        cylinders.push({
            id: i,
            x: spacing * (i + 1) - cylW / 2,
            baseY: canvas.height - 350,
            up: false,
            animY: canvas.height - 350
        });
    }
    document.getElementById('lvl').innerText = "Seviye: " + level;
    document.getElementById('msg').innerText = "Sırayı bul ve it!";
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    cylinders.forEach(c => {
        let hedef = c.up ? c.baseY - 250 : c.baseY;
        c.animY += (hedef - c.animY) * 0.1;

        const poleX = c.x + (cylW / 2) - (poleW / 2);
        const poleStartTop = c.animY + (cylH / 2); 
        const poleHeight = canvas.height - poleStartTop;

        if (imgCubuk.complete && imgCubuk.naturalWidth > 0) {
            ctx.drawImage(imgCubuk, poleX, poleStartTop, poleW, poleHeight);
        } else {
            ctx.fillStyle = "#95a5a6";
            ctx.fillRect(poleX, poleStartTop, poleW, poleHeight);
        }

        if (imgSilindir.complete && imgSilindir.naturalWidth > 0) {
            ctx.drawImage(imgSilindir, c.x, c.animY, cylW, cylH);
        } else {
            ctx.fillStyle = "#d35400";
            ctx.fillRect(c.x, c.animY, cylW, cylH);
        }
    });

    requestAnimationFrame(draw);
}

canvas.addEventListener('mousedown', (e) => {
    // Eğer animasyon sürüyorsa veya işlem yapılıyorsa yeni tıklamayı reddet
    if (isLocked) return;

    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;

    // Tıklanan silindiri bulmak için "found" kontrolü ekledik
    let found = false;

    cylinders.forEach(c => {
        if (!found && mx > c.x && mx < c.x + cylW && my > c.animY && my < c.animY + cylH && !c.up) {
            found = true; // Sadece bir silindir için işlem yap
            
            if (c.id === correctSeq[playerIdx]) {
                c.up = true;
                playerIdx++;
                
                if (playerIdx === cylinders.length) {
                    isLocked = true;
                    document.getElementById('msg').innerText = "HARİKA!";
                    setTimeout(() => {
                        level++;
                        init();
                    }, 1200);
                }
            } else {
                isLocked = true;
                c.up = true;
                document.getElementById('msg').innerText = "YANLIŞ SIRA!";
                
                setTimeout(() => {
                    cylinders.forEach(cyl => cyl.up = false);
                    playerIdx = 0;
                    isLocked = false;
                }, 1000);
            }
        }
    });
});

window.onresize = () => { 
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight; 
    init(); 
};

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
init();
draw();
</script>
</body>
</html>

